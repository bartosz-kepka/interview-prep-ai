import type { z } from "zod";
import type { Tables } from "./db/database.types";
import type {
  CreateQuestionCommandSchema,
  ListQuestionsQuerySchema,
  UpdateQuestionCommandSchema,
} from "./lib/questions/validation";

/**
 * Represents a single question item as returned by the API.
 * This DTO is a subset of the 'questions' table entity.
 */
export type QuestionDto = Pick<
  Tables<"questions">,
  "id" | "question" | "answer" | "source" | "created_at" | "updated_at"
>;

/**
 * Represents a single question item in a list.
 * This DTO is a subset of the 'questions' table entity.
 */
export type QuestionListItemDto = Pick<Tables<"questions">, "id" | "question" | "answer" | "source" | "created_at">;

/**
 * Represents the pagination details in a paginated response.
 */
export interface PaginationDto {
  page: number;
  page_size: number;
  total_items: number;
  total_pages: number;
}

/**
 * Represents the paginated response for a list of questions.
 */
export interface PaginatedQuestionsResponseDto {
  data: QuestionListItemDto[];
  pagination: PaginationDto;
}

/**
 * Query model for listing questions with pagination, sorting, and search.
 */
export type ListQuestionsQuery = z.infer<typeof ListQuestionsQuerySchema>;

/**
 * Command model for creating a new question.
 * It contains only the fields required from the user.
 */
export type CreateQuestionCommand = z.infer<typeof CreateQuestionCommandSchema>;

/**
 * DTO for the response when creating a new question.
 * It returns the newly created question without the `updated_at` field.
 */
export type CreateQuestionResponseDto = QuestionListItemDto;

/**
 * Command model for updating an existing question.
 * All fields are optional.
 */
export type UpdateQuestionCommand = z.infer<typeof UpdateQuestionCommandSchema>;

/**
 * DTO for the response when updating a question.
 * It returns the updated question without the `updated_at` field.
 */
export type UpdateQuestionResponseDto = QuestionListItemDto;

/**
 * Command model for generating questions from a source text using AI.
 */
export interface GenerateQuestionsCommand {
  source_text: string;
}

/**
 * Represents a question proposal generated by the AI.
 */
export interface QuestionProposal {
  question: string;
}

/**
 * ViewModel for managing the state of each question on the client-side.
 * It extends the QuestionProposal with UI-specific state.
 */
export type QuestionProposalViewModel = QuestionProposal & {
  id: number; // A temporary, client-side-only ID for list rendering (e.g., array index).
  answer: string; // The user's answer, initially empty.
  selected: boolean; // Whether the question is selected for saving. Defaults to true.
  original_question: string; // The original question text from the AI to check for edits.
};

/**
 * DTO for the response of the AI question generation process.
 */
export interface GenerateQuestionsResponseDto {
  generation_log_id: string;
  question_proposals: QuestionProposal[];
}

/**
 * Represents a single question to be saved from the AI generation.
 * 'edited' flag indicates if the user modified the AI-generated question.
 */
interface QuestionToSave {
  question: string;
  edited: boolean;
  answer?: string;
}

/**
 * Command model for saving AI-generated questions.
 */
export interface SaveGeneratedQuestionsCommand {
  generation_log_id: string;
  questions: QuestionToSave[];
}

/**
 * DTO for the response after saving AI-generated questions.
 */
export interface SaveGeneratedQuestionsResponseDto {
  saved_question_ids: string[];
}
